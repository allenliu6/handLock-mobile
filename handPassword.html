<!DOCTYPE html>
<html>
<head>
	<title>手势密码</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<style>
	body{
		text-align: center;
	}
	#content{
		position: absolute;
		left: 0;
		right: 0;
		top: 0;
		bottom: 0;
		background-color: #e7f9f9;
	}

	a{
		position: absolute;
		right: 2%;
		top: 1%;
		text-decoration: none;
	}
	#canvas{
		display: inline-block;
		margin-top: 20%;
	}
	#title{
		margin-bottom: 10%;
	}
	</style>
</head>
<body>
	<div id="content">
		<canvas id="canvas" height="300"></canvas>
		<div>
			<h2 id="title">请输入密码</h2>
			<form>
				<input type="radio" name="password" checked>设置密码<br>
				<input type="radio" name="password">验证密码
			</form> 
		</div>
	</div>
	
	<script>

	/*
		record: [{x, y},[x, y]]    走过的所有圆心坐标
		lastPoint: {x, y}    = record[record.legnth - 1]    上一个经过的圆心坐标
		arr: []   存储九个初始化圆心坐标 
		控制touchmove事件触发次数
	 */

		function createCircle(chooseType) {// 创建解锁点的坐标，根据canvas的大小来平均分配半径   并遍历绘制出来
 
	        var n = chooseType;// 画出n*n的矩阵 
	        //lastPoint = [];
	        arr = [];
	        // restPoint = [];
	        r = ctx.canvas.width / (2 + 4 * n);// 公式计算 半径和canvas的大小有关
	        for (var i = 0 ; i < n ; i++) {
	            for (var j = 0 ; j < n ; j++) {
	                arr.push({
	                    x: j * 4 * r + 3 * r,
	                    y: i * 4 * r + 3 * r
	                });
	                /*restPoint.push({
	                    x: j * 4 * r + 3 * r,
	                    y: i * 4 * r + 3 * r
	                });*/
	            }
	        }

	        for (let val of arr) {
	        	ctx.fillStyle='#fff'
	        	ctx.strokeStyle = '#CFE6FF';
	        	ctx.lineWidth = 2;
	        	ctx.beginPath();
		    	ctx.arc(val.x, val.y, r, 0, Math.PI * 2);
		    	ctx.fill();
		    	ctx.stroke();
		    }

	        return arr;
	    }

	    function createPoint(val){//使经过的圆心形成小圆			
	        	ctx.fillStyle='#CFE6FF'
	        	ctx.beginPath();
		    	ctx.arc(val.x, val.y, r/2, 0, Math.PI * 2);
		    	ctx.fill();

	    		lastPoint = {
	    			x: val.x,
	    			y: val.y
	    		}
//??????????
	    		record.push(lastPoint)
	    }

	    function addLine(begin, end){//在两个点之间连线
	    	ctx.beginPath();
	    	ctx.moveTo(begin.x, begin.y)
	    	ctx.lineTo(end.x, end.y)
	    	ctx.stroke()
	    }

	    function reset(){//重置画布
	    	ctx.clearRect(0, 0, 300, 300)
	    	createCircle(3)
	    }

	    function testPosition(x, y){//测试点是否在解锁点内，若在内则创建相应小圆
	    	for( let val of arr){
	    		if (Math.abs(x - val.x) < r && Math.abs(y - val.y) < r) {
	    			createPoint(val)
	    			return true
	    		}
	    	}
	    }

	    function updata(x, y){//每次touchmove更新所有画布数据
	    	reset()

	    	let lastcircle;

	    	for(let val of record){
	    		createPoint(val)
	    		if (lastcircle) {
	    			addLine(lastcircle, val)
	    		}else{
	    			lastcircle = val
	    		}
	    	}

	    	testPosition(x, y)
	    	addLine(lastPoint, {x,y})
	    }

	    function addEvent(){//添加touch事件
	    	canvas.addEventListener('touchstart', function(e){
	    		e.preventDefault();

	    		testPosition(e.touches[0].clientX - offsetLeft, e.touches[0].clientY - offsetTop)

	    	})
	    	canvas.addEventListener('touchmove', function(e){
	    		/*addLine(lastPoint, {
	    			x: e.touches[0].clientX - offsetLeft,
	    			y: e.touches[0].clientY - offsetTop
	    		})*/
	    		updata(e.touches[0].clientX - offsetLeft, e.touches[0].clientY - offsetTop)
	    		
	    	})
	    	canvas.addEventListener('touchend', function(e){
	    		reset()
	    	})
	    }




		var canvas = document.getElementById('canvas'),
		offsetTop = canvas.offsetTop,
		offsetLeft = canvas.offsetLeft;

		ctx = canvas.getContext('2d')

	   	var	arr = createCircle(3),
	   		lastPoint,
	   		record = [];
	   	addEvent()

	</script>
</body>
</html>